{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pagesmith","text":"<p>Splitting HTML into pages, preserving HTML tags while respecting the original document structure and text integrity.</p> <p>Utilize blazingly fast lxml parser.</p> <p>How It Works</p> <p>The HtmlPageSplitter class intelligently splits HTML content into appropriately sized pages while ensuring all HTML tags remain properly closed and valid. This preserves both the document structure and styling.</p> <p>You can use refine_html for refining HTML.</p> <p>Also contains class for splitting to pages and extracting Table of Content from pure text</p> <p>How It Works</p> <p>The ChapterDetector class analyzes text to find standard chapter heading formats. It automatically identifies the position of each chapter and extracts the title.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pagesmith\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>HTML Pages</li> <li>Text Pages</li> </ul>"},{"location":"html_splitter/","title":"HTML pages","text":""},{"location":"html_splitter/#split-html-to-pages","title":"Split HTML to Pages","text":"<p>Use class HtmlPageSplitter</p> <pre><code>from pagesmith import HtmlPageSplitter\n\nhtml = \"\"\"\n&lt;p&gt;Start of text\n&lt;a href=\"../Text/chapter1.xhtml\" class=\"very-long-class-name-to-force-splitting\"&gt;\nThis is a link with a very long text that should be split across pages but the tag itself should stay intact\n&lt;/a&gt;\n&lt;span class=\"another-long-class-that-should-not-be-split\"&gt;\nMore text that goes on and on and should also be split into multiple pages while preserving the HTML structure\n&lt;/span&gt;\n&lt;/p&gt;\n\"\"\"\n\nfor page in HtmlPageSplitter(html, target_length=50).pages():\n    print(page)\n</code></pre> <p>Resulting pages</p> Page 1Page 2Page 3Page 4Page 5 <pre><code>&lt;p&gt;Start of text\n&lt;/p&gt;&lt;p&gt;&lt;a href=\"../Text/chapter1.xhtml\" class=\"very-long-class-name-to-force-splitting\"&gt;\nThis is a link with a very long text that &lt;/a&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;p&gt;&lt;a href=\"../Text/chapter1.xhtml\" class=\"very-long-class-name-to-force-splitting\"&gt;should be split across pages but the tag itself &lt;/a&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;p&gt;&lt;a href=\"../Text/chapter1.xhtml\" class=\"very-long-class-name-to-force-splitting\"&gt;should stay intact\n&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=\"another-long-class-that-should-not-be-split\"&gt;\nMore text that goes on and on and should &lt;/span&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;p&gt;&lt;span class=\"another-long-class-that-should-not-be-split\"&gt;also be split into multiple pages while preserving &lt;/span&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;p&gt;&lt;span class=\"another-long-class-that-should-not-be-split\"&gt;the HTML structure\n&lt;/span&gt;&lt;/p&gt;\n</code></pre>"},{"location":"html_splitter/#refine-html","title":"Refine HTML","text":"<p>refine_html is a utility for cleaning up HTML content.</p> <p>It removes unnecessary for reading tags and vertical gaps.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#pagesmith.HtmlPageSplitter","title":"pagesmith.HtmlPageSplitter","text":"<p>Split HTML into pages, preserving HTML tags while respecting the original document structure.</p>"},{"location":"reference/#pagesmith.HtmlPageSplitter-attributes","title":"Attributes","text":""},{"location":"reference/#pagesmith.HtmlPageSplitter.max_error","title":"pagesmith.HtmlPageSplitter.max_error  <code>instance-attribute</code>","text":"<pre><code>max_error = max_size - target_length\n</code></pre>"},{"location":"reference/#pagesmith.HtmlPageSplitter.max_size","title":"pagesmith.HtmlPageSplitter.max_size  <code>instance-attribute</code>","text":"<pre><code>max_size = int(target_length * (1 + error_tolerance))\n</code></pre>"},{"location":"reference/#pagesmith.HtmlPageSplitter.root","title":"pagesmith.HtmlPageSplitter.root  <code>instance-attribute</code>","text":"<pre><code>root = root\n</code></pre>"},{"location":"reference/#pagesmith.HtmlPageSplitter.target_page_size","title":"pagesmith.HtmlPageSplitter.target_page_size  <code>instance-attribute</code>","text":"<pre><code>target_page_size = target_length\n</code></pre>"},{"location":"reference/#pagesmith.HtmlPageSplitter-functions","title":"Functions","text":""},{"location":"reference/#pagesmith.HtmlPageSplitter.pages","title":"pagesmith.HtmlPageSplitter.pages","text":"<pre><code>pages() -&gt; Iterator[str]\n</code></pre> <p>Split content into pages.</p>"},{"location":"reference/#pagesmith.PageSplitter","title":"pagesmith.PageSplitter","text":"<p>Split pure text into pages at natural break points such as paragraphs or sentences.</p>"},{"location":"reference/#pagesmith.PageSplitter-attributes","title":"Attributes","text":""},{"location":"reference/#pagesmith.PageSplitter.end","title":"pagesmith.PageSplitter.end  <code>instance-attribute</code>","text":"<pre><code>end = len(text) if end == 0 else end\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter.error_tolerance","title":"pagesmith.PageSplitter.error_tolerance  <code>instance-attribute</code>","text":"<pre><code>error_tolerance = error_tolerance\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter.max_length","title":"pagesmith.PageSplitter.max_length  <code>instance-attribute</code>","text":"<pre><code>max_length = int(target_length * (1 + error_tolerance))\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter.min_length","title":"pagesmith.PageSplitter.min_length  <code>instance-attribute</code>","text":"<pre><code>min_length = int(target_length * (1 - error_tolerance))\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter.start","title":"pagesmith.PageSplitter.start  <code>instance-attribute</code>","text":"<pre><code>start = start\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter.target_length","title":"pagesmith.PageSplitter.target_length  <code>instance-attribute</code>","text":"<pre><code>target_length = target_length\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter.text","title":"pagesmith.PageSplitter.text  <code>instance-attribute</code>","text":"<pre><code>text = text\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter-functions","title":"Functions","text":""},{"location":"reference/#pagesmith.PageSplitter.find_nearest_page_end","title":"pagesmith.PageSplitter.find_nearest_page_end","text":"<pre><code>find_nearest_page_end(page_start_index: int) -&gt; int\n</code></pre> <p>Find the nearest page end.</p>"},{"location":"reference/#pagesmith.PageSplitter.find_nearest_page_end_match","title":"pagesmith.PageSplitter.find_nearest_page_end_match","text":"<pre><code>find_nearest_page_end_match(page_start_index: int, pattern: Pattern[str]) -&gt; int | None\n</code></pre> <p>Find the nearest regex match around expected end of page.</p> <p>In no such match in the vicinity, return None. Calculate the vicinity based on the expected PAGE_LENGTH_TARGET and PAGE_LENGTH_ERROR_TOLERANCE.</p>"},{"location":"reference/#pagesmith.PageSplitter.handle_p_tag_split","title":"pagesmith.PageSplitter.handle_p_tag_split","text":"<pre><code>handle_p_tag_split(page_start_index: int, nearest_page_end: int) -&gt; int\n</code></pre> <p>Find the position of the last closing </p> tag before the split."},{"location":"reference/#pagesmith.PageSplitter.normalize","title":"pagesmith.PageSplitter.normalize","text":"<pre><code>normalize(text: str) -&gt; str\n</code></pre>"},{"location":"reference/#pagesmith.PageSplitter.pages","title":"pagesmith.PageSplitter.pages","text":"<pre><code>pages() -&gt; Iterator[str]\n</code></pre> <p>Split a text into pages of approximately equal length.</p> <p>Also clear headings and recollect them during pages generation.</p>"},{"location":"reference/#pagesmith.ChapterDetector","title":"pagesmith.ChapterDetector","text":"<p>Detect chapters in pure text to create a Table of Contents.</p>"},{"location":"reference/#pagesmith.ChapterDetector-attributes","title":"Attributes","text":""},{"location":"reference/#pagesmith.ChapterDetector.min_chapter_distance","title":"pagesmith.ChapterDetector.min_chapter_distance  <code>instance-attribute</code>","text":"<pre><code>min_chapter_distance = min_chapter_distance\n</code></pre>"},{"location":"reference/#pagesmith.ChapterDetector-functions","title":"Functions","text":""},{"location":"reference/#pagesmith.ChapterDetector.get_chapters","title":"pagesmith.ChapterDetector.get_chapters","text":"<pre><code>get_chapters(page_text: str) -&gt; list[Chapter]\n</code></pre> <p>Detect chapter headings in the text.</p> <p>Return a list of Chapter objects containing: - title: The chapter title - position: The character position in the text where the chapter starts</p>"},{"location":"reference/#pagesmith.ChapterDetector.prepare_chapter_patterns","title":"pagesmith.ChapterDetector.prepare_chapter_patterns","text":"<pre><code>prepare_chapter_patterns() -&gt; list[Pattern[str]]\n</code></pre> <p>Prepare regex patterns for detecting chapter headings.</p>"},{"location":"reference/#pagesmith.refine_html","title":"pagesmith.refine_html","text":""},{"location":"reference/#pagesmith.refine_html-attributes","title":"Attributes","text":""},{"location":"reference/#pagesmith.refine_html.ALLOWED_TAGS","title":"pagesmith.refine_html.ALLOWED_TAGS  <code>module-attribute</code>","text":"<pre><code>ALLOWED_TAGS = ('p', 'div', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'a', 'img', 'br', 'hr', 'table', 'tr', 'td', 'th', 'thead', 'tbody', 'b', 'i', 'strong', 'em', 'code', 'pre', 'blockquote', 'sub', 'small', 'sup')\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.CDATA_END","title":"pagesmith.refine_html.CDATA_END  <code>module-attribute</code>","text":"<pre><code>CDATA_END = ']]&gt;'\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.CDATA_START","title":"pagesmith.refine_html.CDATA_START  <code>module-attribute</code>","text":"<pre><code>CDATA_START = '&lt;![CDATA['\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.KEEP_EMPTY_TAGS","title":"pagesmith.refine_html.KEEP_EMPTY_TAGS  <code>module-attribute</code>","text":"<pre><code>KEEP_EMPTY_TAGS = ('img', 'br', 'hr', 'input', 'a')\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.REMOVE_WITH_CONTENT","title":"pagesmith.refine_html.REMOVE_WITH_CONTENT  <code>module-attribute</code>","text":"<pre><code>REMOVE_WITH_CONTENT = ('script', 'style', 'head', 'iframe', 'noscript')\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.TAGS_WITH_CLASSES","title":"pagesmith.refine_html.TAGS_WITH_CLASSES  <code>module-attribute</code>","text":"<pre><code>TAGS_WITH_CLASSES = {'h1': 'display-4 fw-semibold text-primary mb-4', 'h2': 'display-5 fw-semibold text-secondary mb-3', 'h3': 'h3 fw-normal text-dark mb-3', 'h4': 'h4 fw-normal text-dark mb-2', 'h5': 'h5 fw-normal text-dark mb-2'}\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.input_html","title":"pagesmith.refine_html.input_html  <code>module-attribute</code>","text":"<pre><code>input_html = \"&lt;![CDATA[This is CDATA content with &lt;tags&gt; that shouldn't be parsed]]&gt;\"\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.logger","title":"pagesmith.refine_html.logger  <code>module-attribute</code>","text":"<pre><code>logger = getLogger(__name__)\n</code></pre>"},{"location":"reference/#pagesmith.refine_html.result","title":"pagesmith.refine_html.result  <code>module-attribute</code>","text":"<pre><code>result = refine_html(input_html)\n</code></pre>"},{"location":"reference/#pagesmith.refine_html-functions","title":"Functions","text":""},{"location":"reference/#pagesmith.refine_html.collapse_consecutive_br","title":"pagesmith.refine_html.collapse_consecutive_br","text":"<pre><code>collapse_consecutive_br(root: Element, keep_empty_tags_set: set[str], ids_to_keep_set: set[str]) -&gt; None\n</code></pre> <p>From  tags sequence, keep only the first one.</p> <p>This function searches for consecutive  tags and removes all but the first one in each sequence. Whitespace between  tags is ignored for determining consecutive tags.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Element</code> <p>The root element of the lxml tree</p> required"},{"location":"reference/#pagesmith.refine_html.has_meaningful_content","title":"pagesmith.refine_html.has_meaningful_content","text":"<pre><code>has_meaningful_content(element: Element, keep_empty_tags_set: set[str], ids_to_keep_set: set[str], check_tail: bool = True) -&gt; bool\n</code></pre> <p>Check if element/children has non-whitespace content or in the <code>keep_empty_tags_set</code>.</p>"},{"location":"reference/#pagesmith.refine_html.process_class_and_style","title":"pagesmith.refine_html.process_class_and_style","text":"<pre><code>process_class_and_style(root: Element, tags_with_classes: dict[str, str]) -&gt; None\n</code></pre> <p>Remove class and style attributes from elements not in tags_with_classes.</p>"},{"location":"reference/#pagesmith.refine_html.refine_html","title":"pagesmith.refine_html.refine_html","text":"<pre><code>refine_html(input_html: str | None = None, *, root: Optional[Element] = None, allowed_tags: Iterable[str] = ALLOWED_TAGS, tags_to_remove_with_content: Iterable[str] = REMOVE_WITH_CONTENT, keep_empty_tags: Iterable[str] = KEEP_EMPTY_TAGS, ids_to_keep: Iterable[str] = (), tags_with_classes: dict[str, str] | None = None) -&gt; str\n</code></pre> <p>Sanitize and normalize HTML content.</p> <p>Parameters:</p> Name Type Description Default <code>input_html</code> <code>str | None</code> <p>HTML string to clean</p> <code>None</code> <code>root</code> <code>Optional[Element]</code> <p>Alternatively instead of input_html - lxml tree root element</p> <code>None</code> <code>allowed_tags</code> <code>Iterable[str]</code> <p>Tags that are allowed in the output HTML</p> <code>ALLOWED_TAGS</code> <code>tags_to_remove_with_content</code> <code>Iterable[str]</code> <p>Tags to be completely removed along with their content</p> <code>REMOVE_WITH_CONTENT</code> <code>keep_empty_tags</code> <code>Iterable[str]</code> <p>Tags that should be kept even if they have no content</p> <code>KEEP_EMPTY_TAGS</code> <code>ids_to_keep</code> <code>Iterable[str]</code> <p>IDs that should be kept even if their tags are not in allowed_tags</p> <code>()</code> <code>tags_with_classes</code> <code>dict[str, str] | None</code> <p>Dictionary mapping tag names to class strings to add</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Cleaned HTML string</p>"},{"location":"reference/#pagesmith.refine_html.remove_empty_elements","title":"pagesmith.refine_html.remove_empty_elements","text":"<pre><code>remove_empty_elements(ids_to_keep_set: set[str], keep_empty_tags_set: set[str], root: Element) -&gt; None\n</code></pre> <p>Remove empty elements and divs that contain only  tags and whitespace.</p> <p>Parameters:</p> Name Type Description Default <code>ids_to_keep_set</code> <code>set[str]</code> <p>Set of element IDs that should be preserved</p> required <code>keep_empty_tags_set</code> <code>set[str]</code> <p>Set of tags that should be kept even when empty</p> required <code>root</code> <code>Element</code> <p>The root element of the lxml tree</p> required <p>Returns:</p> Type Description <code>None</code> <p>List of removed elements</p>"},{"location":"reference/#pagesmith.refine_html.remove_tags_with_content","title":"pagesmith.refine_html.remove_tags_with_content","text":"<pre><code>remove_tags_with_content(root: Element, tags_to_remove_set: set[str]) -&gt; None\n</code></pre> <p>Remove specified tags along with their content.</p>"},{"location":"reference/#pagesmith.refine_html.unwrap_unknow_tags","title":"pagesmith.refine_html.unwrap_unknow_tags","text":"<pre><code>unwrap_unknow_tags(allowed_tags_set: set[str], ids_to_keep_set: set[str], root: Element) -&gt; None\n</code></pre> <p>Unwrap tags that are not in the allowed set but preserve their content.</p>"},{"location":"text_splitter/","title":"Text Pages","text":""},{"location":"text_splitter/#split-text-to-pages","title":"Split Text to Pages","text":"<p>Use class PageSplitter</p> <pre><code>from pagesmith import PageSplitter\n\ntext = \"\"\"\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\"\"\"\nfor page in PageSplitter(text, target_page_size=50).pages():\n    print(page)\n</code></pre>"},{"location":"text_splitter/#detect-chapters-in-text","title":"Detect Chapters in Text","text":"<p>Use class ChapterDetector to find chapter headings in plain text.</p> <pre><code>from pagesmith import ChapterDetector\n\npage1_text = \"\"\"\nSome introduction text here.\n\nChapter 1. The Beginning\n\nThis is the content of the first chapter with lots of text that goes on and on.\n\nChapter 2. The Development\n\nMore content here for the second chapter.\n\nXII. The Final Chapter\n\nThe ending content.\n\"\"\"\n\ndetector = ChapterDetector()\nchapters = detector.get_chapters(page1_text)\n\nfor chapter in chapters:\n    print(f\"{chapter.title} (position {chapter.position})\")\n</code></pre> <p>Output</p> <pre><code>Chapter 1. The Beginning (position 42)\nChapter 2. The Development (position 134)\nXII. The Final Chapter (position 201)\n</code></pre> <p>The detector recognizes various chapter formats:</p> <ul> <li>\"Chapter 1\", \"Chapter I\", \"Chapter one\"</li> <li>\"1. Title\", \"XII. Title\"</li> <li>Multilingual: \"\u0413\u043b\u0430\u0432\u0430 1\", \"Glava 1\"</li> </ul>"}]}